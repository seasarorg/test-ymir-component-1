
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Text;
using System.Reflection;

using Seasar.Dao;
using Seasar.Dao.Attrs;
using Seasar.Dao.Dbms;
using Seasar.Dao.Impl;
using Seasar.Extension.ADO;
using Seasar.Extension.ADO.Impl;
using Seasar.Extension.ADO.Types;
using Seasar.Framework.Beans;
using Seasar.Framework.Util;

using ${glPackageBaseCommon};
using ${glPackageBaseCommonAnnotation};
using ${glPackageBaseCommonCBean};
using ${glPackageBaseCommonCBeanOutsidesql};
using ${glPackageBaseCommonDBMeta};
using ${glPackageBaseCommonJavaLike};
using ${glPackageBaseCommonJdbc};
using ${glPackageBaseCommonS2DaoInternalSqlCommand};
using ${glPackageBaseCommonS2DaoInternalSqlHandler};

namespace ${glPackageBaseCommonS2Dao} {

    public class ${glDaoMetaDataExtension} : Seasar.Dao.Impl.DaoMetaDataImpl {

        // ===============================================================================
        //                                                                       Attribute
        //                                                                       =========
        protected Map<Type, IBeanMetaData> _beanMetaDataCacheMap = new HashMap<Type, IBeanMetaData>();

        // ===============================================================================
        //                                                                     Constructor
        //                                                                     ===========
        public ${glDaoMetaDataExtension}()
            : base() {}

        // ===============================================================================
        //                                                         Initialization Override
        //                                                         =======================
        public override void Initialize() {
            _daoInterface = GetDaoInterface(_daoType);
            _annotationReader = AnnotationReaderFactory.CreateDaoAnnotationReader(_daoType);
            _beanType = _annotationReader.GetBeanType();
            _dbms = DbmsManager.GetDbms(_dataSource);
			
			// Initialize bean-meta-data!
            BeanMetaDataCacheHandler handler = new BeanMetaDataCacheHandler(_beanMetaDataCacheMap);
            _beanMetaData = handler.FindOrCreateCachedMetaIfNeeds(_beanType, _annotationReaderFactory, _dbMetaData, _dbms);
			if (_beanMetaData == null) {
			    _beanMetaData = new BeanMetaDataCacheExtension(_beanType, _annotationReaderFactory, false);// Don't use cache!
			}

            // For lazy initializing methods!
            // SetupSqlCommand();
        }
		
        public override ISqlCommand GetSqlCommand(String methodName) {
            ISqlCommand cmd = (ISqlCommand)_sqlCommands[methodName];
            if (cmd != null) {
                return cmd;
            }
            return InitializeSqlCommand(methodName);
        }

        protected ISqlCommand InitializeSqlCommand(String methodName) {
            if (${glOutsideSqlContextName}.IsExistOutsideSqlContextOnThread()) {
                ${glOutsideSqlContextName} outsideSqlContext = ${glOutsideSqlContextName}.GetOutsideSqlContextOnThread();
                if (outsideSqlContext != null && outsideSqlContext.IsSpecifiedOutsideSql) {
                    return InitializeSpecifiedOutsideSqlCommand(methodName, outsideSqlContext);
                }
            }
            MethodInfo method = _daoInterface.GetMethod(methodName);
            if (method != null && method.IsAbstract) {
                SetupMethod(method);
            }
            ISqlCommand cmd = (ISqlCommand) _sqlCommands[methodName];
            if (cmd != null) {
                return cmd;
            }
            throw new MethodNotFoundRuntimeException(_daoType, methodName, null);
        }

        protected ISqlCommand InitializeSpecifiedOutsideSqlCommand(String sqlCommandKey, ${glOutsideSqlContextName} outsideSqlContext) {
            MethodInfo method = _daoInterface.GetMethod(outsideSqlContext.MethodName);// By real method name.
            if (method != null && method.IsAbstract) {
                if (IsOutsideSqlDaoMethodSelect(method)) {
                    SetupSpecifiedOutsideSqlSelectCommand(sqlCommandKey, method, outsideSqlContext);
                } else {
                    SetupSpecifiedOutsideSqlExecuteCommand(sqlCommandKey, method, outsideSqlContext);
                }
            }
            ISqlCommand cmd = (ISqlCommand) _sqlCommands[sqlCommandKey];
            if (cmd != null) {
                return cmd;
            }
            String msg = "Internal Error! The sql-command is not found:";
            msg = msg + " sqlCommandKey=" + sqlCommandKey;
            msg = msg + " sqlCommands=" + _sqlCommands;
            throw new SystemException(msg);
        }

        protected bool IsOutsideSqlDaoMethodSelect(MethodInfo method) {
            return method.Name.StartsWith("Select");
        }

        // ===============================================================================
        //                                                      Outside Sql Check Override
        //                                                      ==========================
        protected override void SetupMethodByAuto(MethodInfo mi) {
            ${glOutsideSqlAnnotation} outsideSql = Attribute.GetCustomAttribute(mi, typeof(${glOutsideSqlAnnotation})) as ${glOutsideSqlAnnotation};
            if (outsideSql != null) {
                String msg = "This method '" + mi.Name + "()' should use Outside Sql but the file was not found!";
                msg = msg + " Expected sql file name is '" + mi.DeclaringType.Name + "_" + mi.Name + ".sql'";
                throw new SystemException(msg);
            }
            base.SetupMethodByAuto(mi);
        }

        // ===============================================================================
        //                                                          ConditionBean Override
        //                                                          ======================
        protected override void SetupSelectMethodByAuto(MethodInfo methodInfo) {
            String query = _annotationReader.GetQuery(methodInfo.Name);
            IDataReaderHandler handler = CreateDataReaderHandler(methodInfo);
            SelectDynamicCommand cmd = null;
            String[] argNames = MethodUtil.GetParameterNames(methodInfo);
            Type[] argTypes = MethodUtil.GetParameterTypes(methodInfo);
            if (query != null && !StartsWithOrderBy(query)) {
                cmd = CreateSelectDynamicCommand(handler, query);
            } else {
                cmd = CreateSelectDynamicCommand(handler);
                String sql = null;
                if (argTypes.Length == 1 && ValueTypes.GetValueType(argTypes[0]) == ValueTypes.OBJECT) {
                    argNames = new String[] { "dto" };
                    // /----------------------------------------------------- [MyExtension]
                    if (${glConditionBeanContextName}.IsTheTypeConditionBean(argTypes[0])) {
                        ${glSelectDynamicCommand} dynamicCommand = CreateCustomizeSelectDynamicCommand(handler);
                        cmd = dynamicCommand;
                    } else {
                        if (typeof(${glSelectResourceInterfaceName}).IsAssignableFrom(argTypes[0])) {
                            String msg = "If the first argument type is select-resource(and not condition-bean), ";
                            msg = msg + "the method should not use auto-select-sql-by-dto.";
                            msg = msg + " (Do you want to use outside-sql? Please check your sql-file-name and build-action!)";
                            msg = msg + ": dao=" + methodInfo.DeclaringType + " method=" + methodInfo.Name + "()";
                            msg = msg + " firstArgument=" + argTypes[0] + " argTypes.Length=" + argTypes.Length;
                            throw new SystemException(msg);
                        }
                        sql = CreateAutoSelectSqlByDto(argTypes[0]);
                    }
                    // -----------/
                } else {
                    // /----------------------------------------------------- [MyExtension]
                    if (argTypes.Length > 1 && ValueTypes.GetValueType(argTypes[0]) == ValueTypes.OBJECT) {
                        if (typeof(${glSelectResourceInterfaceName}).IsAssignableFrom(argTypes[0])) {
                            String msg = "If the number of argument is more than 1 and the first argument type is select-resource, ";
                            msg = msg + "the method should not use auto-select-sql.";
                            msg = msg + " (Do you want to use outer-file-sql? Please check your sql-file-name and build-action!)";
                            msg = msg + ": dao=" + methodInfo.DeclaringType + " method=" + methodInfo.Name + "()";
                            msg = msg + " firstArgument=" + argTypes[0] + " argTypes.Length=" + argTypes.Length;
                            throw new SystemException(msg);
                        }
                    }
                    // -----------/
                    sql = CreateAutoSelectSql(argNames, argTypes);
                }
                if (query != null) {
                    sql = sql + " " + query;
                }
				if (sql != null) {
                    cmd.Sql = sql;
				}
            }
            cmd.ArgNames = argNames;
            cmd.ArgTypes = argTypes;
            _sqlCommands[methodInfo.Name] = cmd;
        }

        // ===============================================================================
        //                                   Insert and Update and Delete By Auto Override
        //                                   =============================================
        protected override AbstractSqlCommand CreateInsertAutoDynamicCommand(MethodInfo methodInfo, IDataSource dataSource, ICommandFactory commandFactory, IBeanMetaData beanMetaData, string[] propertyNames) {
            return new ${glInternalInsertAutoDynamicCommand}(dataSource, commandFactory, beanMetaData, propertyNames);
        }
		
        protected override void SetupUpdateMethodByAuto(MethodInfo mi) {
            if (IsFirstArgumentConditionBean(mi)) {
                ISqlCommand cmd = new ${glInternalUpdateQueryAutoDynamicCommand}(_dataSource, _commandFactory);
                _sqlCommands.Add(mi.Name, cmd);
                return;
            }
            base.SetupUpdateMethodByAuto(mi);
        }
        
        protected override AbstractSqlCommand CreateUpdateAutoDynamicCommand(MethodInfo method, IDataSource dataSource, ICommandFactory commandFactory, IBeanMetaData beanMetaData, string[] propertyNames) {
            ${glInternalUpdateAutoDynamicCommand} cmd = new ${glInternalUpdateAutoDynamicCommand}(dataSource, commandFactory, CreateBeanMetaData4UpdateDeleteByAuto(method), propertyNames);
            cmd.VersionNoAutoIncrementOnMemory = IsUpdateVersionNoAutoIncrementOnMemory(method);
            return cmd;
        }
		
        protected override AbstractSqlCommand CreateUpdateModifiedOnlyCommand(MethodInfo method, IDataSource dataSource, ICommandFactory commandFactory, IBeanMetaData beanMetaData, string[] propertyNames) {
            ${glInternalUpdateModifiedOnlyCommand} cmd = new ${glInternalUpdateModifiedOnlyCommand}(dataSource, commandFactory, CreateBeanMetaData4UpdateDeleteByAuto(method), propertyNames);
            cmd.VersionNoAutoIncrementOnMemory = IsUpdateVersionNoAutoIncrementOnMemory(method);
            return cmd;
        }

        protected override void SetupDeleteMethodByAuto(MethodInfo mi) {
            if (IsFirstArgumentConditionBean(mi)) {
                ISqlCommand cmd = new ${glInternalDeleteQueryAutoDynamicCommand}(_dataSource, _commandFactory);
                _sqlCommands.Add(mi.Name, cmd);
                return;
            }
            base.SetupDeleteMethodByAuto(mi);
        }

        protected override AbstractSqlCommand CreateDeleteAutoStaticCommand(MethodInfo method, IDataSource dataSource, ICommandFactory commandFactory, IBeanMetaData beanMetaData, string[] propertyNames) {
            return new ${glInternalDeleteAutoStaticCommand}(dataSource, commandFactory, CreateBeanMetaData4UpdateDeleteByAuto(method), propertyNames);
        }
		
        // -------------------------------------------------
        //                                     Common Helper
        //                                     -------------
        protected IBeanMetaData CreateBeanMetaData4UpdateDeleteByAuto(MethodInfo method) {
            if (IsNonstrictMethod(method)) {
                BeanMetaDataForUpdateNonConcurrency bmdNonConcurrency = new BeanMetaDataForUpdateNonConcurrency(_beanType, _annotationReaderFactory, false);
                bmdNonConcurrency.Initialize(_dbMetaData, _dbms);
                return bmdNonConcurrency;
            } else {
                return this.BeanMetaData;
            }
        }

        protected bool IsUpdateVersionNoAutoIncrementOnMemory(MethodInfo mi) {
            return !IsNonstrictMethod(mi);
        }

        protected bool IsNonstrictMethod(MethodInfo mi) {
            return mi.Name.Contains("Nonstrict");
        }

        protected bool IsFirstArgumentConditionBean(MethodInfo mi) {
            Type[] pmbTypes = MethodUtil.GetParameterTypes(mi);
            return pmbTypes.Length > 0 && typeof(${glConditionBeanInterfaceName}).IsAssignableFrom(pmbTypes[0]);
        }

        // ===============================================================================
        //                                                             OutsideSql Override
        //                                                             ===================
        protected override void SetupSelectMethodByManual(MethodInfo mi, string sql) {
            string[] parameterNames = MethodUtil.GetParameterNames(mi);
            Type[] parameterTypes = MethodUtil.GetParameterTypes(mi);
            string[] filteredParameterNames = null;
            Type[] filteredParameterTypes = null;
            if (parameterTypes != null && parameterTypes.Length > 0
                    && typeof(${glCursorHandlerName}).IsAssignableFrom(parameterTypes[parameterTypes.Length - 1])) {
                filteredParameterNames = new string[parameterTypes.Length - 1];
                filteredParameterTypes = new Type[parameterTypes.Length - 1];
                for (int i = 0; i < parameterTypes.Length - 1; i++) {
                    filteredParameterNames[i] = parameterNames[i];
                    filteredParameterTypes[i] = parameterTypes[i];
                }
            } else {
                filteredParameterNames = parameterNames;
                filteredParameterTypes = parameterTypes;
            }
            IBeanMetaData myMetaData = GetOutsideSqlBeanMetaData(mi, _dbMetaData, _dbms);
            IDataReaderHandler myDataReaderHandler = CreateDataReaderHandler(mi, myMetaData);
            RegisterSqlCommand(mi.Name, mi, sql, filteredParameterNames, filteredParameterTypes, myDataReaderHandler);
        }

        protected IBeanMetaData GetOutsideSqlBeanMetaData(MethodInfo mi, IDatabaseMetaData databaseMetaData, Seasar.Dao.IDbms dbInfo) {
            Type beanClass4SelectMethodByManual = GetOutsideSqlDefaultBeanClass(mi);
            if (beanClass4SelectMethodByManual.Equals(_beanType)) {
                return _beanMetaData;
            }
            BeanMetaDataCacheExtension bmdExt = new BeanMetaDataCacheExtension(beanClass4SelectMethodByManual, _annotationReaderFactory, false);
            bmdExt.Initialize(databaseMetaData, dbInfo);// Don't use cache!
            return bmdExt;
        }

        // -------------------------------------------------
        //                              Specified OutsideSql
        //                              --------------------
        // - - - - - - - - - -
        //              Select
        //               - - -
        protected void SetupSpecifiedOutsideSqlSelectCommand(String sqlCommandKey, MethodInfo method, ${glOutsideSqlContextName} outsideSqlContext) {
            // - - - - - - - - - - - - - - - - - - - - - - -
            // The attribute of Specified-OutsideSqlContext.
            // - - - - - - - - - - - - - - - - - - - - - - -
            String sql = outsideSqlContext.ReadFilteredOutsideSql(this.SqlFileEncoding, _dbms.Suffix);
            Object pmb = outsideSqlContext.ParameterBean;
            Object resultTypeSpecification = outsideSqlContext.ResultTypeSpecification;

            // - - - - - - - - - - - - - - -
            // The attribute of SqlCommand.
            // - - - - - - - - - - - - - - -
            String[] argNames = (pmb != null ? new String[] {"pmb"} : new String[]{});
            Type[] argTypes = (pmb != null ? new Type[] {pmb.GetType()} : new Type[]{});

            // - - - - - - - - - - - - - - - -
            // Create customized BeanMetaData.
            // - - - - - - - - - - - - - - - -
            Type lastestArguementType = method.GetParameters()[method.GetParameters().Length - 1].ParameterType;
            IDataReaderHandler myDataReaderHandler;
            if (typeof(Type).IsAssignableFrom(lastestArguementType)) {
                // - - - - - - - -
                // EntityHandling
                // - - - - - - - -
                Type customizeEntityType = (Type)resultTypeSpecification;
                IBeanMetaData myBeanMetaData = CreateSpecifiedOutsideSqlCustomizeBeanMetaData(customizeEntityType);
                Type retType = method.ReturnType;
                if (retType.IsGenericType && (retType.GetGenericTypeDefinition().Equals(typeof(System.Collections.Generic.IList<>)))) {
                    myDataReaderHandler = CreateSpecifiedOutsideSqlCustomizeBeanListResultSetHandler(myBeanMetaData, customizeEntityType);
				} else if (retType.Equals(typeof(System.Collections.IList))) {
				    // For the problem about DynamicProxy unsupporting generic method!
					myDataReaderHandler = CreateSpecifiedOutsideSqlCustomizeBeanListResultSetHandler(myBeanMetaData, customizeEntityType);
                } else {
                    throw new NotSupportedException("The return type of method is unsupported: method.ReturnType=" + method.ReturnType);
                }
            } else if (typeof(${glCursorHandlerName}).IsAssignableFrom(lastestArguementType)) {
                // - - - - - - - -
                // CursorHandling
                // - - - - - - - -
                IBeanMetaData myBeanMetaData = CreateSpecifiedOutsideSqlCursorBeanMetaData(method);
                myDataReaderHandler = CreateSpecifiedOutsideSqlCursorResultSetHandler(myBeanMetaData);
            } else {
                String msg = "The lastestArguementType is unsupported:";
                msg = msg + " lastestArguementType=" + lastestArguementType;
                msg = msg + " method=" + method;
                throw new SystemException(msg);
            }

            // - - - - - - - - - - -
            // Register Sql-Command.
            // - - - - - - - - - - -
            RegisterSqlCommand(sqlCommandKey, method, sql, argNames, argTypes, myDataReaderHandler);
        }

        protected IBeanMetaData CreateSpecifiedOutsideSqlCustomizeBeanMetaData(Type clazz) {
            BeanMetaDataCacheExtension bmdExt = new BeanMetaDataCacheExtension(clazz, this.AnnotationReaderFactory, false);
            bmdExt.Initialize(_dbMetaData, _dbms);// Don't use cache!
            return bmdExt;
        }

        protected IDataReaderHandler CreateSpecifiedOutsideSqlCustomizeBeanListResultSetHandler(IBeanMetaData specifiedBeanMetaData, Type customizeEntityType) {
            IValueType valueType = ValueTypes.GetValueType(customizeEntityType);
            if (valueType == null || !valueType.Equals(ValueTypes.OBJECT)) {
                return new InternalObjectGenericListResultSetHandler(customizeEntityType, valueType);
            }
            return new BeanGenericListMetaDataDataReaderHandler(specifiedBeanMetaData, new RowCreatorExtension(), new RelationRowCreatorExtension());
        }

        public class InternalObjectGenericListResultSetHandler : IDataReaderHandler {
            private Type _beanType;
            private IValueType _valueType;
            public InternalObjectGenericListResultSetHandler(Type beanType, IValueType valueType) {
                this._beanType = beanType;
                this._valueType = valueType;
            }
            public object Handle(IDataReader dataReader) {
                Type generic = typeof(System.Collections.Generic.List<>);
                Type constructed = generic.MakeGenericType(_beanType);
                System.Collections.IList resultList = (System.Collections.IList) Activator.CreateInstance(constructed);
                while (dataReader.Read()) {
                    resultList.Add(_valueType.GetValue(dataReader, 0));// It's zero origin.
                }
                return resultList;
            }
        }

        protected IBeanMetaData CreateSpecifiedOutsideSqlCursorBeanMetaData(MethodInfo method) {
            BeanMetaDataCacheExtension bmdExt = new BeanMetaDataCacheExtension(GetOutsideSqlDefaultBeanClass(method), this.AnnotationReaderFactory, false);
            bmdExt.Initialize(_dbMetaData, _dbms);// Don't use cache!
            return bmdExt;
        }

        protected IDataReaderHandler CreateSpecifiedOutsideSqlCursorResultSetHandler(IBeanMetaData specifiedBeanMetaData) {
            return new ObjectDataReaderHandler();// This is dummy for cursor handling!
        }

        // - - - - - - - - - -
        //             Execute
        //             - - - -
        protected void SetupSpecifiedOutsideSqlExecuteCommand(String sqlCommandKey, MethodInfo method, ${glOutsideSqlContextName} outsideSqlContext) {
            // - - - - - - - - - - - - - - - - - - - - - - -
            // The attribute of Specified-OutsideSqlContext.
            // - - - - - - - - - - - - - - - - - - - - - - -
            String sql = outsideSqlContext.ReadFilteredOutsideSql(this.SqlFileEncoding, _dbms.Suffix);
            Object pmb = outsideSqlContext.ParameterBean;

            // - - - - - - - - - - - - - - -
            // The attribute of SqlCommand.
            // - - - - - - - - - - - - - - -
            String[] argNames = (pmb != null ? new String[] {"pmb"} : new String[]{});
            Type[] argTypes = (pmb != null ? new Type[] {pmb.GetType()} : new Type[]{});

            InternalSpecifiedOusideSqlUpdateDynamicCommand cmd = new InternalSpecifiedOusideSqlUpdateDynamicCommand(_dataSource, _commandFactory);
            RegisterSqlCommand(sqlCommandKey, method, sql, argNames, argTypes, cmd);
        }

        protected class InternalSpecifiedOusideSqlUpdateDynamicCommand : ${glInternalUpdateDynamicCommand} {
            public InternalSpecifiedOusideSqlUpdateDynamicCommand(IDataSource dataSource, ICommandFactory factory)
                : base(dataSource, factory) {
            }
            public override Object Execute(Object[] args) {
                if (args.Length != 3) {
                    String msg = "Internal Error! OutsideSqlDao.execute() should have 3 arguements: args.length=" + args.Length;
                    throw new SystemException(msg);
                }
                Object arg = args[1];
				return base.Execute(new Object[]{arg});
            }
        }
		
        // -------------------------------------------------
        //                              Common of OutsideSql
        //                              --------------------
        protected Type GetOutsideSqlDefaultBeanClass(MethodInfo mi) {
            Type retType = mi.ReturnType;
            if (retType.IsGenericType && (retType.GetGenericTypeDefinition().Equals(typeof(System.Collections.Generic.IList<>)))) {
                return retType.GetGenericArguments()[0];
            } else if (!retType.IsGenericType && typeof(System.Collections.IList).IsAssignableFrom(retType)) {
                return _beanType;
            } else if (retType.IsArray) {
                return retType.GetElementType();
            } else if (ValueTypes.GetValueType(retType) != ValueTypes.OBJECT) {
                return _beanType;
            } else {
                return retType;
            }
        }

        protected void RegisterSqlCommand(String sqlCommandKey, MethodInfo method, String sql, String[] argNames, Type[] argTypes, IDataReaderHandler myDataReaderHandler) {
            SelectDynamicCommand cmd = CreateSelectDynamicCommand(myDataReaderHandler);
            RegisterSqlCommand(sqlCommandKey, method, sql, argNames, argTypes, cmd);
        }

        protected void RegisterSqlCommand(String sqlCommandKey, MethodInfo method, String sql, String[] argNames, Type[] argTypes, SelectDynamicCommand cmd) {
            cmd.Sql = sql;
            cmd.ArgNames = argNames;
            cmd.ArgTypes = argTypes;
            _sqlCommands.Add(sqlCommandKey, cmd);
        }

        protected void RegisterSqlCommand(String sqlCommandKey, MethodInfo method, String sql, String[] argNames, Type[] argTypes, ${glInternalUpdateDynamicCommand} cmd) {
            cmd.Sql = sql;
            cmd.ArgNames = argNames;
            cmd.ArgTypes = argTypes;
            _sqlCommands.Add(sqlCommandKey, cmd);
        }

        // ===============================================================================
        //                                                              Extension Override
        //                                                              ==================
        protected override SelectDynamicCommand CreateSelectDynamicCommand(IDataReaderHandler handler) {
            return CreateCustomizeSelectDynamicCommand(handler);
        }

        protected virtual ${glSelectDynamicCommand} CreateCustomizeSelectDynamicCommand(IDataReaderHandler handler) {
            ${glFetchNarrowingResultSetFactory} customizeResultSetFactory = new ${glFetchNarrowingResultSetFactory}();
            return new ${glSelectDynamicCommand}(_dataSource, _commandFactory, handler, customizeResultSetFactory);
        }

        protected override Seasar.Dao.IRowCreator CreateRowCreator() {
            return new RowCreatorExtension();
        }

        protected override Seasar.Dao.IRelationRowCreator CreateRelationRowCreator() {
            return new RelationRowCreatorExtension();
        }
		
        // ===============================================================================
        //                                                                BeanMetaData Map
        //                                                                ================
        public Map<Type, IBeanMetaData> BeanMetaDataCacheMap {
            get { return _beanMetaDataCacheMap; }
            set { _beanMetaDataCacheMap = value; }
        }
    }

	public class BeanMetaDataDBFluteDBMetaExtension : BeanMetaDataImpl {
	    protected ${glPackageBaseCommonJavaLike}.List<IPropertyType> _primaryKeyList = new ${glPackageBaseCommonJavaLike}.ArrayList<IPropertyType>();
        public BeanMetaDataDBFluteDBMetaExtension() 
            : base() {
        }
        protected override void SetupProperty(Type beanType, IDatabaseMetaData dbMetaData, IDbms dbms) {
            if (!IsEntity(beanType)) {
                base.SetupProperty(beanType, dbMetaData, dbms);
                return;
            }
            ${glEntityInterfaceName} entity = (${glEntityInterfaceName})ClassUtil.NewInstance(beanType);
            ${glDBMetaInterfaceName} dbmeta = entity.DBMeta;
            foreach (PropertyInfo pi in beanType.GetProperties()) {
                IPropertyType pt = null;
                RelnoAttribute relnoAttr = _beanAnnotationReader.GetRelnoAttribute(pi);
                if (relnoAttr != null) {
                    if (!_relation) {
                        IRelationPropertyType rpt = CreateRelationPropertyType(beanType, pi, relnoAttr, dbMetaData, dbms);
                        AddRelationPropertyType(rpt);
                    }
                } else {
                    if (pi.CanWrite) {
                        pt = CreatePropertyTypeExtension(pi, dbmeta);
                        if (pt != null) {
                            AddPropertyType(pt);
                            if (pt.IsPrimaryKey) {
                                _primaryKeyList.add(pt);
                            }
                        }
                    }
                }
                if (IdentifierGenerator == null) {
                    IDAttribute idAttr = _beanAnnotationReader.GetIdAttribute(pi, dbms);
                    if (idAttr != null) {
                        _identifierGenerator = Seasar.Dao.Id.IdentifierGeneratorFactory.CreateIdentifierGenerator(pi.Name, dbms, idAttr);
                        if (pt != null) {
                            _primaryKeys = new string[] { pt.ColumnName };
                            pt.IsPrimaryKey = true;
                        }
                    }
                }
            }
        }
        protected IPropertyType CreatePropertyTypeExtension(PropertyInfo pi, ${glDBMetaInterfaceName} dbmeta) {
            if (IsRelationProperty(pi, dbmeta)) {
                return null;
            }
            String columnName = GetPropertyTypeColumnName(pi);
            IValueType valueType = ValueTypes.GetValueType(pi.PropertyType);
            IPropertyType pt = new PropertyTypeImpl(pi, valueType, columnName);
            if (dbmeta.HasPrimaryKey && dbmeta.HasColumn(pt.ColumnName)) {
                if (dbmeta.FindColumnInfo(pt.ColumnName).IsPrimary) {
                    pt.IsPrimaryKey = true;
                }
            }
            pt.IsPersistent = IsPersistentProperty(pi, dbmeta);
            return pt;
        }
        protected String GetPropertyTypeColumnName(PropertyInfo pi) {
            String columnName = _beanAnnotationReader.GetColumn(pi);
            columnName = (columnName != null ? columnName : pi.Name);
            return columnName;
        }
        protected bool IsRelationProperty(PropertyInfo pi, ${glDBMetaInterfaceName} dbmeta) {
            String propertyName = pi.Name;
            if (dbmeta.HasForeign(propertyName) || dbmeta.HasReferrer(propertyName)) {
                return true;
            }
            return _beanAnnotationReader.GetRelnoAttribute(pi) != null;
        }
        protected bool IsPersistentProperty(PropertyInfo pi, ${glDBMetaInterfaceName} dbmeta) {
            String propertyName = pi.Name;
            if (dbmeta.HasColumn(propertyName) || _beanAnnotationReader.GetColumn(pi) != null) {
                if (!IsElementOfNoPersistentProps(pi)) {
                    return true;
                }
            }
            return false;
        }
        protected bool IsElementOfNoPersistentProps(PropertyInfo pi) {
            String propertyName = pi.Name;
            String[] props = _beanAnnotationReader.GetNoPersisteneProps();
            if (props != null && props.Length >= 0) {
                for (int i = 0; i < props.Length; ++i) {
                    if (props[i].Equals(propertyName)) {
                        return true;
                    }
                }
            }
            return false;
        }
        protected override void SetupDatabaseMetaData(Type beanType, IDatabaseMetaData dbMetaData, IDbms dbms) {
            if (IsEntity(beanType)) {
			    SetupPrimaryKeyExtension(beanType, dbMetaData, dbms);
			    return;
			}
            base.SetupDatabaseMetaData(beanType, dbMetaData, dbms);
        }
		protected void SetupPrimaryKeyExtension(Type beanType, IDatabaseMetaData dbMetaData, IDbms dbms) {
		    // = = = = = = = = = = = = = = = = = = = = = = =
		    // Set up _primaryKeys and _identifierGenerator!
		    // = = = = = = = = = = = = = = = = = = = = = = =
			if (_primaryKeys == null || _primaryKeys.Length == 0) {
                _primaryKeys = new String[_primaryKeyList.size()];
                int index = 0;
                foreach (IPropertyType pt in _primaryKeyList) {
                    _primaryKeys[index] = pt.ColumnName;
                    ++index;
                }
			}
			if (_identifierGenerator == null) {
                _identifierGenerator = Seasar.Dao.Id.IdentifierGeneratorFactory.CreateIdentifierGenerator(null, dbms);
			}
		}
		protected bool IsEntity(Type beanType) {
            return typeof(${glEntityInterfaceName}).IsAssignableFrom(beanType);
        }
        public override bool HasModifiedPropertyNamesPropertyName {
            get {
                return BeanType.GetProperty(_modifiedPropertyNamesPropertyName) != null;
            }
        }
        public override bool HasClearModifiedPropertyNamesMethodName {
            get {
                return BeanType.GetMethod(_clearModifiedPropertyNamesMethodName) != null;
            }
        }
        public override IDictionary GetModifiedPropertyNames(object bean) {
            String propertyName = _modifiedPropertyNamesPropertyName;
            if (!HasModifiedPropertyNamesPropertyName) {
                throw new NotFoundModifiedPropertiesRuntimeException(bean.GetType().Name, propertyName);
            }
            PropertyInfo modifiedPropertyType = BeanType.GetProperty(propertyName);
            object value = modifiedPropertyType.GetValue(bean, null);
            IDictionary names = (IDictionary)value;
            return names;
        }
        public override void ClearModifiedPropertyNames(object bean) {
            if (HasClearModifiedPropertyNamesMethodName) {
                MethodInfo mi = BeanType.GetMethod(ClearModifiedPropertyNamesMethodName);
                mi.Invoke(bean, null);
            } else if (HasModifiedPropertyNamesPropertyName) {
                PropertyInfo pi = BeanType.GetProperty(ModifiedPropertyNamesPropertyName);
                IDictionary modifiedPropertyNames = (IDictionary)pi.GetValue(bean, null);
                modifiedPropertyNames.Clear();
            }
        }
    }
	
    public class BeanMetaDataCacheExtension : BeanMetaDataDBFluteDBMetaExtension {
	    protected Map<Type, IBeanMetaData> _metaMap;
	    protected int _nestNo;
		
        public BeanMetaDataCacheExtension(Type beanType, IAnnotationReaderFactory annotationReaderFactory, bool relation) 
            : base() {
            this.BeanType = beanType;
            this._relation = relation;
            this.AnnotationReaderFactory = annotationReaderFactory;
        }
		
        public override void Initialize(IDatabaseMetaData dbMetaData, IDbms dbms) {
            if (_metaMap != null) {
                BeanMetaDataCacheHandler handler = new BeanMetaDataCacheHandler(_metaMap);
                Type myBeanClass = BeanType;
                if (handler.IsDBFluteEntity(myBeanClass)) {
                    IBeanMetaData cachedMeta = handler.GetMetaFromCache(myBeanClass);
                    if (cachedMeta == null) {
                        handler.AddMetaFromCache(myBeanClass, this);
                    }
                }
            }
            base.Initialize(dbMetaData, dbms);
        }

        protected override IBeanMetaData CreateRelationBeanMetaData(PropertyInfo propertyInfo, IDatabaseMetaData dbMetaData, IDbms dbms) {
            if (_metaMap != null) {
                BeanMetaDataCacheHandler handler = new BeanMetaDataCacheHandler(_metaMap);
                IBeanMetaData cachedBmd = handler.FindOrCreateCachedMetaIfNeeds(propertyInfo.PropertyType, AnnotationReaderFactory, dbMetaData, dbms);
				if (cachedBmd != null) {
				    return cachedBmd;
				}
            }
            bool isRelation = false;
            if (this.NestNo > 0) {
                isRelation = true;
            }
            BeanMetaDataCacheExtension bmdExt = new BeanMetaDataCacheExtension(propertyInfo.PropertyType, this.AnnotationReaderFactory, isRelation);
            bmdExt.NestNo = this.NestNo + 1;
            bmdExt.Initialize(dbMetaData, dbms);
            return bmdExt;
        }
		
        public Map<Type, IBeanMetaData> MetaMap {
            get { return _metaMap; }
            set { _metaMap = value; }
        }
        public int NestNo {
            get { return _nestNo; }
            set { _nestNo = value; }
        }
    }

    public class BeanMetaDataForUpdateNonConcurrency : BeanMetaDataDBFluteDBMetaExtension {
        public BeanMetaDataForUpdateNonConcurrency(Type beanType, IAnnotationReaderFactory annotationReaderFactory, bool relation) 
            : base() {
            this.BeanType = beanType;
            this._relation = relation;
            this.AnnotationReaderFactory = annotationReaderFactory;
        }
        public override bool HasVersionNoPropertyType {
            get { return false; }
        }

        public override bool HasTimestampPropertyType {
            get { return false; }
        }
    }

    public class RowCreatorExtension : Seasar.Dao.Impl.RowCreatorImpl {

        public override object CreateRow(IDataReader reader, IColumnMetaData[] columns, Type beanType) {
            object row = NewBean(beanType);
            ${glDBMetaInterfaceName} dbmeta = FindDBMeta(row);
            foreach (IColumnMetaData column in columns) {
                object value = column.ValueType.GetValue(reader, column.ColumnName);
				if (dbmeta != null && dbmeta.HasEntityPropertySetupper(column.PropertyInfo.Name)) {
				    dbmeta.SetupEntityProperty(column.PropertyInfo.Name, row, value);
					continue;
                }
                column.PropertyInfo.SetValue(row, value, null);
            }
            return row;
        }

		protected ${glDBMetaInterfaceName} FindDBMeta(Object row) {
		    return EntityPropertySetupperHandler.FindCachedDBMeta(row);
        }
    }

	public class EntityPropertySetupperHandler {
	    protected static readonly String DBMETA_CACHE_KEY = "df:DBMetaCache";
		
		public static ${glDBMetaInterfaceName} FindCachedDBMeta(Object row) {
		    if (!(row is ${glEntityInterfaceName})) {
			    return null;
			}
			${glEntityInterfaceName} entity = (${glEntityInterfaceName})row;
            IDictionary<Type, ${glDBMetaInterfaceName}> dbmetaCache = (IDictionary<Type, ${glDBMetaInterfaceName}>)${glInternalMapContextName}.GetObject(DBMETA_CACHE_KEY);
			if (dbmetaCache == null) {
			    dbmetaCache = new Dictionary<Type, ${glDBMetaInterfaceName}>();
				${glInternalMapContextName}.SetObject(DBMETA_CACHE_KEY, dbmetaCache);
			}
            ${glDBMetaInterfaceName} dbmeta = null;
            if (dbmetaCache.ContainsKey(entity.GetType())) {
                dbmeta = dbmetaCache[entity.GetType()];
				if (dbmeta != null) {
				    return dbmeta;
				}
            }
            dbmeta = entity.DBMeta;
            dbmetaCache.Add(entity.GetType(), dbmeta);
		    return dbmeta;
        }
	}
	
    public class RelationRowCreatorExtension : Seasar.Dao.Impl.RelationRowCreatorImpl {

        protected override void SetupRelationAllValue(RelationRowCreationResource res) {
            IDictionary<String, IPropertyType> propertyCacheElement = res.ExtractPropertyCacheElement();
            ICollection<String> columnNameCacheElementKeySet = propertyCacheElement.Keys;
            foreach (String columnName in columnNameCacheElementKeySet) {
                IPropertyType pt = propertyCacheElement[columnName];
                res.CurrentPropertyType = pt;
                if (!IsValidRelationPerPropertyLoop(res)) {
                    res.ClearRowInstance();
                    return;
                }
                SetupRelationProperty(res);
            }
            if (!IsValidRelationAfterPropertyLoop(res)) {
                res.ClearRowInstance();
                return;
            }
            res.ClearValidValueCount();
            if (res.HasNextRelationProperty() && (HasConditionBean(res) || res.HasNextRelationLevel())) {
                SetupNextRelationRow(res);
            }
        }

        protected override void RegisterRelationValue(RelationRowCreationResource res, String columnName) {
            IPropertyType pt = res.CurrentPropertyType;
            Object value = null;
            if (res.ContainsRelKeyValueIfExists(columnName)) {
                value = res.ExtractRelKeyValue(columnName);
            } else {
                IValueType valueType = pt.ValueType;
                value = valueType.GetValue(res.DataReader, columnName);
            }
            if (value != null) {
                res.IncrementValidValueCount();
				${glDBMetaInterfaceName} dbmeta = FindDBMeta(res.Row);
				String propertyName = pt.PropertyName;
				if (dbmeta != null && dbmeta.HasEntityPropertySetupper(propertyName)) {
				    dbmeta.SetupEntityProperty(propertyName, res.Row, value);
			    } else {
                    PropertyInfo pd = pt.PropertyInfo;
                    pd.SetValue(res.Row, value, null);
				}
            }
        }
		
		protected ${glDBMetaInterfaceName} FindDBMeta(Object row) {
		    return EntityPropertySetupperHandler.FindCachedDBMeta(row);
        }
		
        protected override void SetupPropertyCache(RelationRowCreationResource res) {
            // - - - - - - - - - - - 
            // Recursive Call Point!
            // - - - - - - - - - - -
            res.InitializePropertyCacheElement();

            // Do only selected foreign property for performance if condition-bean exists.
            if (HasConditionBean(res)) {
                ${glConditionBeanInterfaceName} cb = ${glConditionBeanContextName}.GetConditionBeanOnThread();
                if (!cb.SqlClause.hasSelectedForeignInfo(res.RelationNoSuffix)) {
                    return;
                }
            }

            // Set up property cache about current beanMetaData.
            IBeanMetaData nextBmd = res.GetRelationBeanMetaData();
            for (int i = 0; i < nextBmd.PropertyTypeSize; ++i) {
                IPropertyType pt = nextBmd.GetPropertyType(i);
                res.CurrentPropertyType = pt;
                if (!IsTargetProperty(res)) {
                    continue;
                }
                SetupPropertyCacheElement(res);
            }

            // Set up next relation.
            if (res.HasNextRelationProperty() && (HasConditionBean(res) || res.HasNextRelationLevel())) {
                res.BackupRelationPropertyType();
                res.IncrementCurrentRelationNestLevel();
                try {
                    SetupNextPropertyCache(res, nextBmd);
                } finally {
                    res.RestoreRelationPropertyType();
                    res.DecrementCurrentRelationNestLevel();
                }
            }
        }

        protected override bool IsTargetProperty(RelationRowCreationResource res) {
            IPropertyType pt = res.CurrentPropertyType;
            if (!pt.PropertyInfo.CanWrite) {
                return false;
            }
            if (typeof(System.Collections.Generic.IList<>).IsAssignableFrom(pt.PropertyInfo.GetType())) {
                return false;
            }
            return true;
        }

        protected override bool IsCreateDeadLink() {
            return false;
        }

        protected override int GetLimitRelationNestLevel() {
            return 2;
        }

        protected bool HasConditionBean(RelationRowCreationResource res) {
            return ${glConditionBeanContextName}.IsExistConditionBeanOnThread();
        }
    }
	
    public class BeanMetaDataCacheHandler {
        protected Map<Type, IBeanMetaData> _metaMap;
        public BeanMetaDataCacheHandler(Map<Type, IBeanMetaData> metaMap) {
            _metaMap = metaMap;
        }
        public IBeanMetaData FindOrCreateCachedMetaIfNeeds(Type beanClass, IAnnotationReaderFactory factory, IDatabaseMetaData dbMetaData, IDbms dbms) {
            if (IsDBFluteEntity(beanClass)) {
                IBeanMetaData cachedMeta = GetMetaFromCache(beanClass);
                if (cachedMeta != null) {
                    return cachedMeta;
                } else {
                    BeanMetaDataCacheExtension bmdExt = new BeanMetaDataCacheExtension(beanClass, factory, false);
                    bmdExt.MetaMap = _metaMap;
                    bmdExt.Initialize(dbMetaData, dbms);
                    return bmdExt;
                }
            }
            return null;
        }

        public IBeanMetaData FindCachedMeta(Type beanClass) {
            if (IsDBFluteEntity(beanClass)) {
                IBeanMetaData cachedMeta = GetMetaFromCache(beanClass);
                if (cachedMeta != null) {
                    return cachedMeta;
                }
            }
            return null;
        }

        public bool IsDBFluteEntity(Type beanClass) {
            return typeof(${glEntityInterfaceName}).IsAssignableFrom(beanClass);
        }

        public IBeanMetaData GetMetaFromCache(Type beanClass) {
            lock (_metaMap) {
                return _metaMap.get(beanClass);
            }
        }
        public IBeanMetaData AddMetaFromCache(Type beanClass, IBeanMetaData metaData) {
            lock (_metaMap) {
                return _metaMap.put(beanClass, metaData);
            }
        }
    }
}